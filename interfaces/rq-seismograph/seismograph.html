


<html>
<head>

	<script src="bower_components/bower-mqttws/mqttws31.js" type="text/javascript" charset="utf-8"></script>
	<script src="bower_components/simple-js-mqtt-client/simple-js-mqtt-client.js"></script>
	<script src="bower_components/nutella_lib/nutella_lib.js" charset="utf-8"></script>
	
	<script src="bower_components/Processing.js/processing.js"></script>

<link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css" type="text/css" media="screen"
          title="no title" charset="utf-8">

<link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:700' rel='stylesheet' type='text/css'>

</head>

<style>

body {background-color:black;
}


a {
	position: absolute;
	left: 60px;
	top: 50px;
    color: rgba(255,255,255,1);
    text-decoration: none;
    background-color: rgba(175,175,175,1);
    font-family: 'Yanone Kaffeesatz';
    font-weight: 700;
    font-size: 3em;
    display: block;
    padding: 4px;
    -webkit-border-radius: 8px;
    -moz-border-radius: 8px;
    border-radius: 8px;
    -webkit-box-shadow: 0px 9px 0px rgba(100,100,100,1), 0px 9px 25px rgba(0,0,0,.7);
    -moz-box-shadow: 0px 9px 0px rgba(100,100,100,1), 0px 9px 25px rgba(0,0,0,.7);
    box-shadow: 0px 9px 0px rgba(100,100,100,1), 0px 9px 25px rgba(0,0,0,.7);
    margin: 10px auto;
	width: 200px;
	text-align: center;
	
	-webkit-transition: all .1s ease;
	-moz-transition: all .1s ease;
	-ms-transition: all .1s ease;
	-o-transition: all .1s ease;
	transition: all .1s ease;
}
/* BL added to remove undelined text */
a:active {
    -webkit-box-shadow: 0px 0px 0px rgba(100,100,100,1), 0px 3px 6px rgba(0,0,0,.9);
    -moz-box-shadow: 0px 0px 0px rgba(100,100,100,1), 0px 3px 6px rgba(0,0,0,.9);
    box-shadow: 0px 0px 0px rgba(100,100,100,1), 0px 3px 6px rgba(0,0,0,.9);
    position: absolute;
    text-decoration: none;
    top: 60px;
	left: 60px
}

a:hover, a:visited{
	text-decoration: none;
}

</style>

<body onresize="location.reload();"> <!-- my solution to the resize problem :-) -->

<script>

const WINDOW_WIDTH = window.innerWidth;
const WINDOW_HEIGHT = window.innerHeight-20;

const TOP_PANEL_HEIGHT = 80;
const LEFT_PANEL_WIDTH = 50;
const RIGHT_PANEL_WIDTH = 50;
const BOTTOM_PANEL_HEIGHT = 50;
const SEISMOGRAM_WIDTH = WINDOW_WIDTH - LEFT_PANEL_WIDTH - RIGHT_PANEL_WIDTH; 
const SEISMOGRAM_HEIGHT = WINDOW_HEIGHT - TOP_PANEL_HEIGHT - BOTTOM_PANEL_HEIGHT;

	var TOTAL_QUAKES = 0;

	var LIVE = true; //There are two operational modes: LIVE and HISTORY
	var JUST_LIVE = true;
	var JUST_BACK = false;


</script>



<style>

#top {
	background-color:black;
	color:white;
	height: 10px;
	text-align:left;
}

#left {
    background-color:black;
	height:10px;
    width:10px;
    float:left;
}

#seismogram {
    background-color:black;
	height:10px;
	width:10px;
    float:left;

}
#right {
    background-color:black;
	height:10px;
    width:10px;
    float:left;

}
#bottom {
    background-color:black;
    color:white;
	height:10px;
    clear:both;
    text-align:center;
 }
 img.bolt-tl{/*top left bolt*/
    position: fixed;
	left: 3%;
    top: 3%;
	width: 2%;
	height: auto;
	z-index: 1;
}
img.bolt-tr{/*top right bolt*/
    position: fixed;
	left: 96%;
    top: 3%;
	width: 2%;
    height: auto;
	z-index: 1;
}
img.bolt-bl{/*bottom left bolt*/
    position: fixed;
	left: 3%;
    top: 94%;
	width: 2%;
	height: auto;
	z-index: 1;
}
img.bolt-br{/*bottom right bolt*/
    position: fixed;
	left: 96%;
    top: 94%;
	width: 2%;
    height: auto;
	z-index: 1;
}
.button {
  background-image: url(_images/button1.png);
  padding:5px;  
}
.wrapper {max-width: 100%;
    height: auto;
    width: auto\9; /* ie8 */}
.resize {z-index:1; position:absolute; width:100%; height:100%;}

</style>


<div class="wrapper">
  <img class="resize" id="seismoframe" src="_images/frame0.png" />
  <img class="bolt-tl" src="_images/bolt.png">
  <div style="max-width=10%;">
  	<img class="bolt-tr" src="_images/bolt.png">
  	<img class="bolt-bl" src="_images/bolt.png">
  	<img class="bolt-br" src="_images/bolt.png">
  </div>
</div>

<div id="top" style="z-index:1;">
	<script>
	document.getElementById("top").style.height = TOP_PANEL_HEIGHT + "px";
	</script>
	<a id="back" class="button" href="javascript:void(0);" on mouseover=";" 
		onClick="
			if (LIVE) { if ((LAST_QUAKE > 0) && (!in_event)) {STEPS_BACK=0; LIVE=false; JUST_BACK=true;};}
			else { if (LAST_QUAKE - STEPS_BACK > 1) {STEPS_BACK++;JUST_BACK=true;}} " style="z-index:1;">Back</a>
	<script> document.getElementById("back").style.left = WINDOW_WIDTH-540; document.getElementById("back").style.top = WINDOW_HEIGHT - 80;</script>

<!--	
	<a id="print" class="button" href="javascript:void(0);" on mouseover=";" onClick="window.print();" style="z-index:1;">Print</a>
	<script> document.getElementById("print").style.left =  WINDOW_WIDTH-830; document.getElementById("print").style.top = WINDOW_HEIGHT - 80; </script>
-->

	<a id="forward" class="button" href="javascript:void(0);" on mouseover=";" onClick="
			if (!LIVE) {if (STEPS_BACK==0) {LIVE=true; JUST_LIVE=true;} else {STEPS_BACK--;JUST_BACK=true;}};" style="z-index:1;">Forward</a>

	<script> document.getElementById("forward").style.left = WINDOW_WIDTH-330; document.getElementById("forward").style.top = WINDOW_HEIGHT - 80;</script>
</div>

<div id="left">
<script>
document.getElementById("left").style.height = SEISMOGRAM_HEIGHT + "px";
document.getElementById("left").style.width = LEFT_PANEL_WIDTH + "px";
</script>
</div>


<div id="seismogram">

<p>
    <canvas id="canvas1" style='position:absolute; z-index:0;'></canvas>
</p>
<script>
	var sound = new Audio('earthquake.wav');

document.getElementById("seismogram").style.height = SEISMOGRAM_HEIGHT + "px";
document.getElementById("seismogram").style.width = SEISMOGRAM_WIDTH + "px";


	// constants

	const VIEWING_PERIOD = 20;  						// number of seconds represented by the seismogram
	const SAMPLING_FREQUENCY = 40; 						// how many data points to be computed per second
	const NOISE = .03;								// maximum amplitude of bg noise...percentage of maximum displacement. seems to be disfunctional.
	

	// globals


	var time_interval = 1000 / SAMPLING_FREQUENCY;			// how often does our clock tick per second (hence the 1000) 
															// to update the displacement array?
	var n_displacements = VIEWING_PERIOD * SAMPLING_FREQUENCY;	// total number of data points in the displacement array
	var displacement = [];							// this array holds the normalized displacements (ground motion)
	var in_event = false;								// are we currently drawing the seismogram of a simulated event?
	var event_index;									// what's the next index in the event_buffer array to draw from?
	var event_buffer = [100];							// the next event buffer	
	for (i=0; i<100; i++) event_buffer[i] = new Array(n_displacements);
	

	var last_event_time;								// timestamp of most recent event
	
	var room_width_x_meters;
	var room_height_y_meters;
	var seismograph_loc = {x:0,y:0};				// stores seismograph location, initialized by nutella when room configuration is fetched
	var quakes;								// stores the array of quakes, initialized at reload and updated by nutella when new quake is received
	var whichSEISMOGRAPH;									
	
	///////////////////
	// NUTELLA STUFF //
	///////////////////
	


	// Initialize nutella
	var query_params = nutella.init(location.search, function() {
		// Once initializaiton is complete:
		
		// 1. Fetch room configuration and store the coordinates of the current seismograph
		nutella.request("room_configuration", function(response) { 
			room_width_x_meters = response.room_width_meters;
			room_height_y_meters = response.room_height_meters;
			response.seismographs.forEach(function(e) {
				if (e.id==query_params.seismograph_id) {	whichSEISMOGRAPH = e.id;	
					seismograph_loc.x = e.x; ;
					seismograph_loc.y = e.y; 
				}
			unit_size_meters = Math.sqrt((room_width_x_meters * room_width_x_meters) + (room_height_y_meters * room_height_y_meters));
			});
			if (seismograph_loc.x===undefined || seismograph_loc.y===undefined)
					console.error("Impossible to set seismograph location. The id you provided doens't seem to match any of the know IDs.");
            
            // 2. Fetch quakes schedule
            nutella.request("quakes_schedule", function(response) {
                // Update model
                TOTAL_QUAKES=0;
			quakes = response.quakes_schedule;
                quakes.forEach(function(el, i) {
                    var Devent_loc =  { x: el.location.x, y: el.location.y };
                    var Dtime = new Date(el.time).getTime();
                    event_message (Devent_loc, Dtime, el.magnitude, seismograph_loc);
                });
            });
		});

		// 3. Subscribe to clear events
		nutella.subscribe("demo_quakes_clean", function() {location.reload();});

        // 4. Subscribe to schedule change events
        nutella.subscribe("quakes_schedule_update", function() {location.reload();});

		// 5. Subscribe to quakes schedule updates
		nutella.subscribe("new_demo_quake", function(message) {
			var Devent_loc =  { x: message.location.x, y: message.location.y };
			var Dtime = new Date(message.time).getTime();
			event_message (Devent_loc, Dtime, message.magnitude, seismograph_loc);
		});
	});
	

	
	///////////////////////
	// END NUTELLA STUFF //
	///////////////////////


function ooch() {
	var Devent_loc = {x:5, y:7}
 	var Dmagnitude = 3;
 	var Dtime = new Date().getTime();
 	event_message (Devent_loc, Dtime+2000, Dmagnitude, seismograph_loc);
 }

//setTimeout(ooch, 2000);

	// basic loop for updating displacements array; left shift

	var launch_time = new Date().getTime();
	var synch_index = -1;

	// utility functions

	function signedRandom () {
		return (Math.random() - 0.5)*2;
	}



	// interval_timer is called every time_interval seconds. it updates the seismograph.

	function interval_timer() {
		if (LIVE) {
			if (JUST_LIVE) { 
				for (var i=0; i < n_displacements; i++) {displacement[i] = signedRandom()*NOISE;}
				JUST_LIVE = false;
			}
			// shuffle all the data points (except the last) over to the left

			for (var i=0; i < n_displacements - 1; i++) {displacement[i] = displacement[i+1];}

			// insert a new "last" point, either from the event buffer or random

			if (in_event) {
				displacement[n_displacements-1] = event_buffer[LAST_QUAKE+1][event_index++];
				if (event_index == n_displacements) {in_event = false; LAST_QUAKE++;}
 			} else {displacement[n_displacements-1] = signedRandom()*NOISE;}  // should be processing.randomGaussian();
	
			// reschedule myself for the next multiple of time_interval

		} else {
			if (JUST_BACK) { 
				for (var i=0; i < n_displacements; i++) {displacement[i] = event_buffer[LAST_QUAKE-STEPS_BACK][i];}
				JUST_BACK = false;
			} 
		}
		if (event_index % 10 == 0) {sound.volume = Math.abs(displacement[n_displacements-1])/4;}
		setTimeout(interval_timer, launch_time + ++synch_index * time_interval - new Date().getTime());

	}

	setTimeout(interval_timer, time_interval);  // clock ticks every time_interval ms to update displacement array

	var START = [];
	var LAST_QUAKE=0;
	var STEPS_BACK=0;
	
	function event_message (event_location, time, magnitude, seismograph_location) {

	//	these are needed in messageReceived()
	//	ultimately they should be included as configuration
	//	options

		const P_SPEED =  1;  	//length units (LUs) per second. a LU is about a meter
		const S_SPEED = .5;		//LUs per second
		TOTAL_QUAKES++;


	//	how far away from here is the event?

			// room_width_x_meters 
			// room_height_y_meters 

		var LU = Math.sqrt((room_width_x_meters * room_width_x_meters) + (room_height_y_meters * room_height_y_meters))/10;

		var distance = Math.sqrt(Math.pow(seismograph_location.x - event_location.x,2) + Math.pow(seismograph_location.y - event_location.y,2))/LU;
	//	so the arrival times for the p and s waves are just the event time plus the 
	//	distance divided by the speeds the waves travel at (p_speed and s_speed) * 1000

		var p_arrivalUPC = time + distance/P_SPEED * 1000; 		// milliseconds since 1/1/1970
		var s_arrivalUPC = time + distance/S_SPEED * 1000;
		var s_minus_p = s_arrivalUPC - p_arrivalUPC;			//S-P in milliseconds, for convenience
	
	//	determine  S-wave magnitude-

		var s_amplitude = Math.abs(((3*(magnitude/10+.2) - Math.log10(distance))/2) * 4); //4 because our scale goes to 4
		var p_amplitude = s_amplitude * .3; //p wave amplitude. totally arbitrary 

	//	so at this point we have normalized displacements (0..1) in the displacement array and normalized amplitudes (0..1) for the p and s waves

		var i = 0; 

		var t = .05;
		
	//	fill the first second (the first 5% of the graph) with noise
		
		while (i < n_displacements*t) event_buffer[TOTAL_QUAKES][i++] = signedRandom() * NOISE;


	//	then the p-wave


		t += ((s_arrivalUPC - p_arrivalUPC) / 1000) / 20;
			
		while (i < n_displacements*t) event_buffer[TOTAL_QUAKES][i++] = signedRandom() * p_amplitude;


	//	then the s-wave


		var t_counter = 0;
		while (i < n_displacements*t) {event_buffer[TOTAL_QUAKES][i++] = signedRandom() * s_amplitude ;}
		

		t = t + (1+magnitude) * .05;
		
			
		while (i < n_displacements*t) event_buffer[TOTAL_QUAKES][i++] = signedRandom() * s_amplitude;


		t += .10;

		t_counter = 0;
		while (i < n_displacements*t) {event_buffer[TOTAL_QUAKES][i++] = signedRandom() * s_amplitude * (1 - t_counter/(3*SAMPLING_FREQUENCY)); t_counter++;}


				
	//	and finish it off with random values
		
		while (i < n_displacements) event_buffer[TOTAL_QUAKES][i++] = signedRandom() * NOISE;

		var this_time = new Date().getTime();
		if (p_arrivalUPC-this_time - 1000 > 0) {
			setTimeout(start_quake, p_arrivalUPC - this_time - 1000);
		}
		START [TOTAL_QUAKES] = p_arrivalUPC - 1000;
 
	}
	



	function rumble () {sound.volume=0.0; sound.play();} 






	function start_quake() {
		JUST_LIVE = true; LIVE = true; STEPS_BACK=0;  	// force return to live action if quake imminent
		last_event_time = new Date().getTime();
		event_index = 0;
		rumble();
		in_event = true;
	}
		
	function sign (x) { return x > 0 ? 1 : x < 0 ? -1 : 0;}

	function sketchProc(processing) {
        // Override draw function, by default it will be called 60 times per second

		processing.setup = function () {
			processing.size(SEISMOGRAM_WIDTH, SEISMOGRAM_HEIGHT);
			processing.fill(255);
			processing.smooth();
 		};

		processing.draw = function () {	
			processing.background(255);
			var available_width = SEISMOGRAM_WIDTH;
			var available_height = SEISMOGRAM_HEIGHT;

	// draw the graph
			
			processing.beginShape();
			processing.fill(255,255,255);
			for (var i = 0; i < n_displacements; i++) {
				processing.stroke(1);
				processing.strokeWeight(2);
				processing.stroke(processing.color(0,0,0,170));
				var middle = SEISMOGRAM_HEIGHT/2;
				processing.vertex(Math.floor(i / n_displacements * available_width), middle - displacement[i]*(SEISMOGRAM_HEIGHT/2)/4);
			}
			processing.endShape();

	// draw the needle

			processing.fill(0,0,0);
			processing.beginShape();
			processing.strokeWeight(1);
			processing.stroke(processing.color(0,0,0));
			
			var left_edge = SEISMOGRAM_WIDTH-50;
			var right_edge = SEISMOGRAM_WIDTH;
			var middle = SEISMOGRAM_HEIGHT/2 - displacement[n_displacements-1]*(SEISMOGRAM_HEIGHT/2)/4;
			var top = middle - 25;
			var bottom = middle + 25;

			processing.vertex(left_edge,middle+10);
			processing.vertex(right_edge,middle+10);
			processing.vertex(right_edge,middle-10);
			processing.vertex(left_edge,middle-10);
			processing.endShape(processing.CLOSE);
			processing.fill(0);

	// draw the bar that that needle sits in
/*
			processing.fill(0,0,0);
			processing.beginShape();
			processing.strokeWeight(6);
			processing.stroke(processing.color(0,0,0));
			processing.vertex(SEISMOGRAM_WIDTH,0)
			processing.vertex(SEISMOGRAM_WIDTH,SEISMOGRAM_HEIGHT)
			processing.vertex(SEISMOGRAM_WIDTH-80,SEISMOGRAM_HEIGHT)
			processing.vertex(SEISMOGRAM_WIDTH-80,0)
			processing.endShape(processing.CLOSE);
			processing.fill(0);


			processing.fill(0,0,0);
			processing.beginShape();
			processing.strokeWeight(6);
			processing.stroke(processing.color(0,0,0));
			processing.vertex(0,0)
			processing.vertex(80,0)
			processing.vertex(80,SEISMOGRAM_HEIGHT)
			processing.vertex(0,SEISMOGRAM_HEIGHT)
			processing.endShape(processing.CLOSE);
			processing.fill(0);
*/
	// draw the vertical bars and labels

			var this_time;

			if (LIVE) {this_time = new Date().getTime();} else {this_time = START[LAST_QUAKE-STEPS_BACK]+20000;};
			

			// find nearest second prior to current time (lotta hard-wired crap in here)

			var vertical_bar_time = Math.round(this_time/1000) * 1000;
			var vertical_bar_time_offset = (this_time - vertical_bar_time) / 1000;			// in seconds
			var vertical_bar_pixel_offset = (available_width/VIEWING_PERIOD) * vertical_bar_time_offset; 
			var t = new Date();

			for (var i = 0; i< VIEWING_PERIOD+1; i++) {
				t.setTime(vertical_bar_time - i * 1000);
				processing.beginShape(); 
				if (t.getSeconds() % 10 == 0) {
					for (var j=-4; j<=4; j++){
						processing.strokeWeight(1);
						processing.textFont(processing.createFont("sans-serif",20));
						processing.fill(0);
						processing.stroke(processing.color(255,0,0));
						processing.pushMatrix();
						var hack = sign(j); if (hack == 0) hack = 1;
						processing.translate(available_width - vertical_bar_pixel_offset - i * (available_width/VIEWING_PERIOD) +10,SEISMOGRAM_HEIGHT/2 + j*SEISMOGRAM_HEIGHT/8 + 6  - hack*15);
						processing.fill(0,0,200,80);
						if (j !=0 ) {
							if (Math.abs(j) == 4) {processing.text(-j*50 + "mm",0,0);}
							else {processing.text(-j*50,0,0);}
						}
						processing.popMatrix();
						processing.noFill();
					}
				} 
				else {processing.strokeWeight(.4);}
				processing.strokeWeight(2);

				processing.stroke(processing.color(200,0,0,60));
				processing.strokeWeight(2);

				processing.vertex(available_width - vertical_bar_pixel_offset - i * (available_width/VIEWING_PERIOD),0);
				processing.vertex(available_width - vertical_bar_pixel_offset - i * (available_width/VIEWING_PERIOD),SEISMOGRAM_HEIGHT);
				processing.strokeWeight(1);
				processing.endShape();
				var x = available_width - vertical_bar_pixel_offset - i * (available_width/VIEWING_PERIOD) - 10;
				var y = SEISMOGRAM_HEIGHT-25;
				processing.textFont(processing.createFont("sans-serif",20));
				processing.fill(0);
				processing.stroke(processing.color(200,0,0,60));
				processing.pushMatrix();
				processing.stroke(processing.color(200,0,0,60));
				processing.fill(200,0,0,90);
				processing.translate(x,y);
				processing.rotate(-3.14159/2);
				if (t.getSeconds() % 5 == 0) {processing.text(t.toUTCString(),0,0);}
				processing.popMatrix();
				processing.noFill();
			}

	// draw the horizontal bars

			for (i=-4; i <= +4; i++) {
				if (i == 0) processing.strokeWeight(2); else processing.strokeWeight(1);
				processing.beginShape();
				processing.stroke(processing.color(0,0,200,60));
				processing.vertex(0, SEISMOGRAM_HEIGHT/2 - i * SEISMOGRAM_HEIGHT/8);
				processing.vertex(available_width+40, SEISMOGRAM_HEIGHT/2 - i * SEISMOGRAM_HEIGHT/8);
				processing.endShape();
			}		

			processing.textAlign(processing.LEFT);
			processing.textSize(28);
			processing.fill(150,150,150);
			processing.text("Seismograph "+whichSEISMOGRAPH,50,90);
			
		}  //end anonymous function definition

	} // end function sketchProc

    var canvas = document.getElementById("canvas1");

    // attaching the sketchProc function to the canvas
    var p = new Processing(canvas, sketchProc);

	

</script>



</div>

<div id="right">
<script>
document.getElementById("right").style.height = SEISMOGRAM_HEIGHT + "px";
document.getElementById("right").style.width = RIGHT_PANEL_WIDTH + "px";
</script>
</div>

<!--

<div id="bottom">
<script>
document.getElementById("bottom").style.height = BOTTOM_PANEL_HEIGHT + "px";
</script>
</div>

-->

</body>
</html>