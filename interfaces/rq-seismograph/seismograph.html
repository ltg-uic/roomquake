


<html>
<head>

	<script src="bower_components/bower-mqttws/mqttws31.js" type="text/javascript" charset="utf-8"></script>
	<script src="bower_components/simple-js-mqtt-client/simple-js-mqtt-client.js"></script>
	<script src="bower_components/nutella_lib/nutella_lib.js" charset="utf-8"></script>
	
	<script src="bower_components/Processing.js/processing.js"></script>

<link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css" type="text/css" media="screen"
          title="no title" charset="utf-8">

<link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:700' rel='stylesheet' type='text/css'>

</head>

<style>

body {background-color:black;
}


a {
	position: absolute;
	left: 60px;
	top: 50px;
    color: rgba(255,255,255,1);
    text-decoration: none;
    background-color: rgba(175,175,175,1);
    font-family: 'Yanone Kaffeesatz';
    font-weight: 700;
    font-size: 3em;
    display: block;
    padding: 4px;
    -webkit-border-radius: 8px;
    -moz-border-radius: 8px;
    border-radius: 8px;
    -webkit-box-shadow: 0px 9px 0px rgba(100,100,100,1), 0px 9px 25px rgba(0,0,0,.7);
    -moz-box-shadow: 0px 9px 0px rgba(100,100,100,1), 0px 9px 25px rgba(0,0,0,.7);
    box-shadow: 0px 9px 0px rgba(100,100,100,1), 0px 9px 25px rgba(0,0,0,.7);
    margin: 10px auto;
	width: 200px;
	text-align: center;
	
	-webkit-transition: all .1s ease;
	-moz-transition: all .1s ease;
	-ms-transition: all .1s ease;
	-o-transition: all .1s ease;
	transition: all .1s ease;
}

a:active {
    -webkit-box-shadow: 0px 0px 0px rgba(100,100,100,1), 0px 3px 6px rgba(0,0,0,.9);
    -moz-box-shadow: 0px 0px 0px rgba(100,100,100,1), 0px 3px 6px rgba(0,0,0,.9);
    box-shadow: 0px 0px 0px rgba(100,100,100,1), 0px 3px 6px rgba(0,0,0,.9);
    position: absolute;
    top: 60px;
	left: 60px
}

</style>

<body onresize="location.reload();"> <!-- my solution to the resize problem :-) -->

<script>

const WINDOW_WIDTH = window.innerWidth;
const WINDOW_HEIGHT = window.innerHeight-20;

const TOP_PANEL_HEIGHT = 80;
const LEFT_PANEL_WIDTH = 50;
const RIGHT_PANEL_WIDTH = 50;
const BOTTOM_PANEL_HEIGHT = 50;
const SEISMOGRAM_WIDTH = WINDOW_WIDTH - LEFT_PANEL_WIDTH - RIGHT_PANEL_WIDTH; 
const SEISMOGRAM_HEIGHT = WINDOW_HEIGHT - TOP_PANEL_HEIGHT - BOTTOM_PANEL_HEIGHT;


</script>



<style>

#top {
	background-color:black;
	color:white;
	height: 10px;
	text-align:left;
}

#left {
    background-color:black;
	height:10px;
    width:10px;
    float:left;
}

#seismogram {
    background-color:black;
	height:10px;
	width:10px;
    float:left;

}
#right {
    background-color:black;
	height:10px;
    width:10px;
    float:left;

}
#bottom {
    background-color:black;
    color:white;
	height:10px;
    clear:both;
    text-align:center;
 }

.wrapper {max-width: 100%;
    height: auto;
    width: auto\9; /* ie8 */}
.resize {z-index:1; position:absolute; width:100%; height:100%;}

</style>

<div class="wrapper">
  <img class="resize" src="_images/frame.png" />
</div>

<div id="top" style="z-index:1;">
	<script>
	document.getElementById("top").style.height = TOP_PANEL_HEIGHT + "px";
	</script>
	<a id="back" href="javascript:void(0);" style="z-index:1;">History</a>
	<script> document.getElementById("back").style.left = 60; </script>
	<a id="forward" href="javascript:void(0);" style="z-index:1;">Future</a>
	<script> document.getElementById("forward").style.left = WINDOW_WIDTH-260; </script>
</div>

<div id="left">
<script>
document.getElementById("left").style.height = SEISMOGRAM_HEIGHT + "px";
document.getElementById("left").style.width = LEFT_PANEL_WIDTH + "px";
</script>
</div>


<div id="seismogram">

<p>
    <canvas id="canvas1" style='position:absolute; z-index:0;'></canvas>
</p>
<script>

document.getElementById("seismogram").style.height = SEISMOGRAM_HEIGHT + "px";
document.getElementById("seismogram").style.width = SEISMOGRAM_WIDTH + "px";


	// constants

	const VIEWING_PERIOD = 20;  						// number of seconds represented by the seismogram
	const SAMPLING_FREQUENCY = 40; 						// how many data points to be computed per second
	const MAX_NOISE = .01;								// maximum amplitude of bg noise...percentage of maximum displacement
	

	// globals

	var time_interval = 1000 / SAMPLING_FREQUENCY;			// how often does our clock tick per second (hence the 1000) 
															// to update the displacement array?
	var n_displacements = VIEWING_PERIOD * SAMPLING_FREQUENCY;	// total number of data points in the displacement array
	var displacement = [];							// this array holds the normalized displacements (ground motion)
	var in_event = false;								// are we currently drawing the seismogram of a simulated event?
	var event_index;									// what's the next index in the event_buffer array to draw from?
	var event_buffer = [];							// the next event buffer	
	var last_event_time;								// timestamp of most recent event
	
	var room_width_x_meters;
	var room_height_y_meters;
	var seismograph_loc = {};				// stores seismograph location, initialized by nutella when room configuration is fetched
	var quakes;									// stores the array of quakes, initialized at reload and updated by nutella when new quake is received
	
	///////////////////
	// NUTELLA STUFF //
	///////////////////
	
	// Initialize nutella
	var query_params = nutella.init(location.search, function() {
		// Once initializaiton is complete:
		
		// 1. Fetch room configuration and store coordinates of current seismograph
		nutella.request("room_configuration", function(response) { 
			room_width_x_meters = response.room_width_meters;
			room_height_y_meters = response.room_height_meters;
			response.seismographs.forEach(function(e) {
				if (e.id==query_params.seismograph_id) {
					seismograph_loc.x = e.x;
					seismograph_loc.y = e.y;
				}
			});
			if (seismograph_loc.x===undefined || seismograph_loc.y===undefined)
					console.error("Impossible to set seismograph location. The id you provided doens't seem to match any of the know IDs.");
		});
		
		// 2. Fetch quakes schedule
		nutella.request("quakes_schedule", function(response) {
			// Update model
			quakes = response.quakes_schedule;
		});

		// 3. Subscribe to quakes schedule updates
		nutella.subscribe("quakes_schedule_update", function(message) {
			console.debug(message);
			var Devent_loc =  { x: message.location.x, y: message.location.y };
			var Dtime = new Date(message.time)
			// Update model
			// TODO gotta place the quake in the right spot based on date
			// Trigger quake drawing
			event_message (Devent_loc, Dtime, message.magnitude, seismograph_loc);
		});
	});
	
	
	///////////////////////
	// END NUTELLA STUFF //
	///////////////////////


	// function ooch() {
	// 	var Devent_loc =  {x:1+Math.floor(Math.random()*7), y:1+Math.floor(Math.random()*7)};
	// 	var Dgraph_loc =  {x:1+Math.floor(Math.random()*7), y:1+Math.floor(Math.random()*7)};
	// 	var Dmagnitude = 2 + Math.floor(Math.random()*4);
	// 	var Dtime = new Date().getTime();
	// 	event_message (Devent_loc, Dtime+10000, Dmagnitude, Dgraph_loc);
	// }


	// basic loop for updating displacements array; left shift

	var launch_time = new Date().getTime();
	var synch_index = -1;

	// utility functions

	function signedRandom () {
		return (Math.random() - 0.5)/2;
	}


	// interval_timer is called every time_interval seconds. it updates the seismograph.

	function interval_timer() {

		// shuffle all the data points (except the last) over to the left

		for (var i=0; i < n_displacements - 1; i++) {displacement[i] = displacement[i+1];}

		// insert a new "last" point, either from the event buffer or random

		if (in_event) {
			displacement[n_displacements-1] = event_buffer[event_index++];
			if (event_index == n_displacements) in_event = false;
 		} else {displacement[n_displacements-1] = signedRandom() * 5;}  // should be processing.randomGaussian();

		// reschedule myself for the next multiple of time_interval

		setTimeout(interval_timer, launch_time + ++synch_index * time_interval - new Date().getTime());
	}


	setTimeout(interval_timer, time_interval);  // clock ticks every time_interval ms to update displacement array


	
	function event_message (event_location, time, magnitude, seismograph_location) {

	//	these are needed in messageReceived()
	//	ultimately they should be included as configuration
	//	options

		const P_SPEED =  1;  	//length units (LUs) per second. a LU is about a meter
		const S_SPEED = .5;		//LUs per second

	//	how far away from here is the event?

		var distance = Math.sqrt(Math.pow(seismograph_location.x - event_location.x,2) + Math.pow(seismograph_location.y - event_location.y,2));

	//	so the arrival times for the p and s waves are just the event time plus the 
	//	distance divided by the speeds the waves travel at (p_speed and s_speed) * 1000

		var p_arrivalUPC = time + distance/P_SPEED * 1000; 		// milliseconds since 1/1/1970
		var s_arrivalUPC = time + distance/S_SPEED * 1000;
		var s_minus_p = s_arrivalUPC - p_arrivalUPC;			//S-P in milliseconds, for convenience
	
	//	determine  S-wave magnitude (normalized to maximum amplitude
		var d = 1 * Math.log(8 * s_minus_p / 1000) - 2.92;  // d is like 4 or something (sorry i can't be more specific)
		var s_amplitude = 2 * Math.log(Math.pow(10,magnitude - d)); 
	 
		var p_amplitude = s_amplitude * (.1 + Math.random() * .2); //p wave amplitude is random height within 20-50% of s_amplitude. totally arbitrary 

	//	so at this point we have normalized displacements (0..1) in the displacement array and normalized amplitudes (0..1) for the p and s waves

		var i = 0; 

		var t = .05;
		
	//	fill the first second (the first 5% of the graph) with noise
		
		while (i < n_displacements*t) event_buffer[i++] = (Math.random() - 0.5) * 2;


	//	then the p-wave


		t += ((s_arrivalUPC - p_arrivalUPC) / 1000) / 20;
			
		while (i < n_displacements*t) event_buffer[i++] = (Math.random() - 0.5) * 5 * p_amplitude;


	//	then the s-wave

		t+= .05;


		var t_counter = 0;
		while (i < n_displacements*t) {event_buffer[i++] = (Math.random() - 0.5) * 5 * s_amplitude * (.8 + .2 * t_counter/(1*SAMPLING_FREQUENCY)); t_counter++;}
		

		t = (t+.80)/3 ;
		t = t + Math.random() * (.80 - t);
		
			
		while (i < n_displacements*t) event_buffer[i++] = (Math.random() - 0.5) * 5 * s_amplitude;


		t += .15;

		t_counter = 0;
		while (i < n_displacements*t) {event_buffer[i++] = (Math.random() - 0.5) * 5 * s_amplitude * (1 - t_counter/(3*SAMPLING_FREQUENCY)); t_counter++;}


				
	//	and finish it off with random values
		
		while (i < n_displacements) event_buffer[i++] = (Math.random() - 0.5) * 2;

		var this_time = new Date().getTime();
		setTimeout(start_quake, p_arrivalUPC - this_time - 1000);

 

	}
	
/*

	function generate_earthquake_waveform (event_time, event_location


*/

	function start_quake() {
		last_event_time = new Date().getTime();
		event_index = 0;
		in_event = true;
	}
		

	function sketchProc(processing) {
        // Override draw function, by default it will be called 60 times per second

		processing.setup = function () {
			processing.size(SEISMOGRAM_WIDTH, SEISMOGRAM_HEIGHT);
			processing.fill(255);
			processing.smooth();
 		};

		processing.draw = function () {			
			processing.background(255);
			var available_width = SEISMOGRAM_WIDTH;
			var available_height = SEISMOGRAM_HEIGHT;

	// draw the graph
			
			processing.beginShape();
			for (var i = 0; i < n_displacements; i++) {
				processing.stroke(1);
				processing.strokeWeight(2);
				processing.stroke(processing.color(30,143,208));
				processing.vertex(Math.floor(i / n_displacements * available_width), SEISMOGRAM_HEIGHT/2 - displacement[i]*4);
			}
			processing.endShape();

	// draw the needle

			processing.fill(30,143,208);
			processing.beginShape();
			processing.strokeWeight(1);
			processing.stroke(processing.color(30,143,208));
			
			var left_edge = SEISMOGRAM_WIDTH-20;
			var right_edge = SEISMOGRAM_WIDTH;
			var middle = SEISMOGRAM_HEIGHT/2 + displacement[n_displacements-1]*4;
			var top = middle - 25;
			var bottom = middle + 25;

			processing.vertex(left_edge,middle);
			processing.vertex(right_edge,bottom);
			processing.vertex(right_edge,top);
			processing.endShape(processing.CLOSE);
			processing.fill(0);

	// draw the bar that that needle sits in
/*
			processing.fill(0,0,0);
			processing.beginShape();
			processing.strokeWeight(6);
			processing.stroke(processing.color(0,0,0));
			processing.vertex(SEISMOGRAM_WIDTH,0)
			processing.vertex(SEISMOGRAM_WIDTH,SEISMOGRAM_HEIGHT)
			processing.vertex(SEISMOGRAM_WIDTH-80,SEISMOGRAM_HEIGHT)
			processing.vertex(SEISMOGRAM_WIDTH-80,0)
			processing.endShape(processing.CLOSE);
			processing.fill(0);


			processing.fill(0,0,0);
			processing.beginShape();
			processing.strokeWeight(6);
			processing.stroke(processing.color(0,0,0));
			processing.vertex(0,0)
			processing.vertex(80,0)
			processing.vertex(80,SEISMOGRAM_HEIGHT)
			processing.vertex(0,SEISMOGRAM_HEIGHT)
			processing.endShape(processing.CLOSE);
			processing.fill(0);
*/
	// draw the vertical bars and labels

			var this_time = new Date().getTime();

			// find nearest second prior to current time (lotta hard-wired crap in here)

			var vertical_bar_time = Math.round(this_time/1000) * 1000;
			var vertical_bar_time_offset = (this_time - vertical_bar_time) / 1000;			// in seconds
			var vertical_bar_pixel_offset = (available_width/VIEWING_PERIOD) * vertical_bar_time_offset; 
			var t = new Date();

			for (var i = 0; i< VIEWING_PERIOD+1; i++) {
				t.setTime(vertical_bar_time - i * 1000);
				processing.beginShape(); 
				if (t.getSeconds() % 5 == 0) {
					for (var j=-4; j<=4; j++){
						processing.strokeWeight(1);
						processing.textFont(processing.createFont("sans-serif",20));
						processing.fill(0);
						processing.stroke(processing.color(255,0,0));
						processing.pushMatrix();
						processing.translate(available_width - vertical_bar_pixel_offset - i * (available_width/VIEWING_PERIOD) +10,SEISMOGRAM_HEIGHT/2 + j*SEISMOGRAM_HEIGHT/8-10);
						processing.text(-j,0,0);
						processing.popMatrix();
						processing.noFill();
					}
				} 
				else {processing.strokeWeight(.4);}
				processing.stroke(processing.color(14,14,14));
				processing.vertex(available_width - vertical_bar_pixel_offset - i * (available_width/VIEWING_PERIOD),0);
				processing.vertex(available_width - vertical_bar_pixel_offset - i * (available_width/VIEWING_PERIOD),SEISMOGRAM_HEIGHT);
				processing.endShape();
				var x = available_width - vertical_bar_pixel_offset - i * (available_width/VIEWING_PERIOD) - 5;
				var y = SEISMOGRAM_HEIGHT-20;
				processing.textFont(processing.createFont("sans-serif",12));
				processing.fill(0);
				processing.stroke(processing.color(30,143,208));
				processing.pushMatrix();
				processing.translate(x,y);
				processing.rotate(-3.14159/2);
				if (t.getSeconds() % 5 == 0) {processing.text(t.toUTCString(),0,0);}
				processing.popMatrix();
				processing.noFill();
			}

	// draw the horizontal bars

			for (i=-4; i <= +4; i++) {
				if (i == 0) processing.strokeWeight(2); else processing.strokeWeight(1);
				processing.beginShape();
				processing.stroke(processing.color(114,114,114));
				processing.vertex(0, SEISMOGRAM_HEIGHT/2 - i * SEISMOGRAM_HEIGHT/8);
				processing.vertex(available_width+40, SEISMOGRAM_HEIGHT/2 - i * SEISMOGRAM_HEIGHT/8);
				processing.endShape();
			}		
 	

		}  //end anonymous function definition

	} // end function sketchProc

    var canvas = document.getElementById("canvas1");

    // attaching the sketchProc function to the canvas
    var p = new Processing(canvas, sketchProc);

	

</script>



</div>

<div id="right">
<script>
document.getElementById("right").style.height = SEISMOGRAM_HEIGHT + "px";
document.getElementById("right").style.width = RIGHT_PANEL_WIDTH + "px";
</script>
</div>

<div id="bottom">
<script>
document.getElementById("bottom").style.height = BOTTOM_PANEL_HEIGHT + "px";
document.writeln("UIC Learning Technologies Group");
</script>
</div>

</body>
</html>