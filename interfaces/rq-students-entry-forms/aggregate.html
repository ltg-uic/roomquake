<html>
<head>
</head>
<body  onresize="location.reload();"> <!-- my solution to the resize problem :-) -->

	<h2>
		<p>
			<canvas id="canvas1"></canvas>
		</p>


		<script src="bower_components/bower-mqttws/mqttws31.js" type="text/javascript" charset="utf-8"></script>
		<script src="bower_components/simple-js-mqtt-client/simple-js-mqtt-client.js" type="text/javascript" charset="utf-8"></script>
		<script src="bower_components/nutella_lib/nutella_lib.js" type="text/javascript" charset="utf-8"></script>

		<script src="bower_components/Processing.js/processing.js"></script>

		<script>
	
		// Globals
		const SEISMO_RADIUS = 30;
		var SEISMOGRAPHS = [{x:150,y:450},{x:300,y:600},{x:700,y:500}];
		// Double array: i, index of the seismohraph, j, index of observation	
		var OBSERVATIONS;
	
		// Initialize nutella and fetch data from backend
		var query_params = nutella.init(location.search, function() {
			// Fetch room configuration
			nutella.request("room_configuration", function(response) {
				// TODO parse this stuff
			});
	
			// Fetch available observations
			nutella.request("observations", function(response) {
				OBSERVATIONS = response.observations;
			});
			
			// Handle incoming observations (subscribe to quake_reports channel)
			// m has format similar to {"section":"6BS","stud_name":"DEF","seismograph":2,"distance":14,"magnitude":5,"from":"oa57Pj4XwCNNDOn3dmPSe5"}
			nutella.subscribe("quake_reports", function(m) {
				var s = m.seismograph-1 	// convert to zero based index in array
				OBSERVATIONS[s][OBSERVATIONS[s].length] = m.distance;
				console.log(OBSERVATIONS);
				console.log(OBSERVATIONS[s]);
			});
			
			// Handle admin events (i.e. wipe) by subscribing to to admin channel 
			nutella.subscribe("wipe_observations", function(m) {
				for (var i=0; i<SEISMOGRAPHS.length; i++) {
					OBSERVATIONS[i] = [];
				}
			});
			
		});
	

		// for testing
		function ooch() {
			var seismograph = Math.floor(Math.random()*SEISMOGRAPHS.length);
			var distance = Math.random()*30;
			var time = Math.random();
			new_observation (seismograph, distance, time);
			setTimeout(ooch, 5000);
		}


		// Assuming six seismographs maximum, each one gets a color
		var R = [Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255];
		var G = [Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255];
		var B = [Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255, Math.random()*255];

		const WINDOW_WIDTH = window.innerWidth;
		const WINDOW_HEIGHT = window.innerHeight-40;


		function sketchProc(processing) {
			// Override draw function, by default it will be called 60 times per second

			processing.setup = function () {
				processing.size(WINDOW_WIDTH,WINDOW_HEIGHT);
				processing.fill(255);
				processing.smooth(8);
				processing.stroke(1);
				processing.strokeWeight(1);
				myFont = processing.createFont("sans-serif",12);
			};

			processing.draw = function () {
				// Return if there is no data to represent
				if (OBSERVATIONS===undefined || SEISMOGRAPHS===undefined) {
					return;
				}			
			
				processing.background(255);

				// draw the seismographs...   
				processing.stroke(processing.color(30,143,208));

				for (var i=0; i<SEISMOGRAPHS.length; i++) {
					processing.fill(processing.color(R[i], G[i], B[i]));
					processing.stroke(processing.color(R[i], G[i], B[i]));
					processing.ellipse(SEISMOGRAPHS[i].x, SEISMOGRAPHS[i].y, SEISMO_RADIUS, SEISMO_RADIUS);
					// ... and for each seismograph, draw its associated rings (if there are some)
					processing.noFill();
					if (OBSERVATIONS[i]===undefined) {
						break;
					}
					for (var j=0; j<OBSERVATIONS[i].length; j++) {
						processing.ellipse(SEISMOGRAPHS[i].x, SEISMOGRAPHS[i].y, 40*OBSERVATIONS[i][j], 40*OBSERVATIONS[i][j]);
					}
				}

			}  //end anonymous function definition

		} // end function sketchProc

		var canvas = document.getElementById("canvas1");

		// attaching the sketchProc function to the canvas
		var p = new Processing(canvas, sketchProc);
		// ooch();
	
		// dummy call to event message handler
	
		// p.exit(); to detach it

		</script>
	</body>
	</html>
	
<!-- QUESTIONS FOR TOM
	A. Aggregate
	1. What about the magnitude? Don't consider in this representation?
	2. What about the orientation of the room? Where is horizontal, where is the origin?
	3. What about the colors? Keep random?
	4. What about the wipe function?
	
	B. Observe
	1. Store all the data but, what is represented? (this has an impact on the backend too)
	 -->